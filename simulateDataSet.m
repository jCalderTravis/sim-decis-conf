function DSet = simulateDataSet(Settings, varargin)
% Simulates evidence accumulation under various conditions, generating RTs, 
% choices and confidence.

% INPUT
% Settings      Fields...
%     TotalTrials           Trials to simulate per participant
%     BlockSize             Number of trials each block
%     DeltaT                Size of time step in the simulations, in seconds.
%     Fps                   Number of stimulus frames per second. 
%     Units                 The units of measurement for time realted input and outputs (eg. RT and
%                           OverallCommitDelay, maxDuration). '1' corresponds to seconds. '0.05' corresponds to units of
%                           50ms
%     NumPtpnts
%     NoiseSD               Noise added as simulation noise internal to the
%                           observer
%     DriftSD               Variability in drift rate. Here it is more correct
%                           to say that there is variability in the quality of
%                           evidence encoding: A normally distributied number
%                           with mean 1, and standard deviation DriftSD, 
%                           multiplies the evidence for the duration of a trial.
%     Threshold             Function handle with input arguments (time, blockType), specifying the 
%                           height of the threshold over time. See the examples
%                           of functions specifying thresholds in this 
%                           folder. BlockType is a number, giving the
%                           position of the block in the struct array
%                           BlockSettings.
%     OverallCommitDelay    Delay between a decision and a response specified in Settings.Units
%     CommitDelaySD         Standard deviation accross participants in OverallCommitDelay in units of Settings.Units
%     WithinPtCommitDelaySD Standard deviation within participants in OverallCommitDelay in units of Settings.Units
%     SeperateConf          Is conf generated by a continuation of the process that led to a
%                           decision (0), or a seperate accumulation process (1)?
%     ConfNoiseSd           Noise added to the computed value for
%                           confidence
%     RandRtLapseRate       Fraction of trials resulting from a random
%                           response time lapse (see simulateTrial for 
%                           details of what this implies)
%     MappingLapseRate      Fraction of trials resulting from a mapping lapse (see simulateTrial)
%     ConfLapseRate         Fraction of trials in which make decision as usual but then give a random
%                           confidence report. (Implimentation: randomly draw a
%                           confidence report from another trial.)
%     Dots                  Has fields...
%       Max                 Maximum number of dots in one of two boxes 
%                           comprising the stimulus
%       Min                 Minimum number of dots in one of two boxes 
%                           comprising the stimulus
%       Sd                  Standard deviation of dot fluctuations around the
%                           high mean, and around the low mean. (Therefore the
%                           s.d. for the fluctuations in the difference between the
%                           two boxes will be higher.)
%     BlockSettings         [numBlockTypes x 1] struct array, specifying the settings
%                           for each block type. Has fields...
%       DotDist             Function handle to function with no inputs and two
%                           outputs. The first specifies the mean number of dots
%                           in the high mean box, and the second specified the
%                           mean number of dots in the low mean box. Note
%                           this function is called every time a new stimulus is
%                           generated, allowing variation between trials in the
%                           mean number of dots used.
%       MaxDuration         Function handle to function with no inputs and one 
%                           output specifying the maximum duration of a trial,
%                           in Settings.Units
%       Type                'free' response or 'forced' response?
%       StimAfterResp       Duration of additional stimulus presentation
%                           following a response. In units of Settings.Units
%       confAccumulationTime 
%                           How long should accumulation continue for, following
%                           a decision? (Note, decision ie. RT - [non-decision time],
%                           *not* the response itself). Accumulation will continue for at
%                           most the duration of the stimulus, even if
%                           confAccumulationTime is set to infinity. Pass in Settings.Units,
%                           units.
%       ForcedEarlyRespProb In the forced response condition, if a threshold is
%                           crossed before the end of a trial, this is the
%                           probability of an immediate response. The
%                           alternative is to withold a response until the end
%                           of the trial but to stop accumulating evidence. 
%                           
%    ConfCalc               string. How to perform the confidence caculations. 
%                           Passed through to addSimConfidence where options
%                           are described.
%    PermitCoM              If set to false then any trial in which confidence
%                           is lower than don't know is ressigned a confidence
%                           of don't know, ie. zero evidence either way.
%    RngSeed                Seed the random number generator with a 'random'
%                           number, or a 'fixed' number.
%    ObserverNoiseRatio     The ratio the observer assumes between various
%                           sources of variability for the purposes of
%                           caculating confidence. Only used if ConfCalc set to
%                           'FaDs'.
%    StimLambda             Allows possilbility that internal representation of
%                           a stimulus corresponds to the stimulus taken to some
%                           power, StimLambda. Default is no effect, i.e.
%                           StimLambda = 1
%                           Note confidence readouts assume StimLambda = 1
%    StimPropNoiseSD        Similar effect to NoiseSD but allows the possibility 
%                           of noise which scales with
%                           the evidence (or with the internal representation of
%                           the evidence in the case that StimLambda is being
%                           used). Default is 0, i.e. no effect.
%                           Note confidence readouts assume StimPropNoiseSD = 0
%    RespLapseRate          The probability of making a random response, once a
%                           response has been triggered. Default 0.
%    PosConfWeight          Number specifying the ratio of weight given to
%                           decision congruent information in the confidence
%                           report, to the weight given to deicsion incongruent.
%                           Default is equal weighting, i.e. 1. Only makes sense
%                           to use if SeperateConf is true, because information
%                           for the decision is always weighted equally.
%                           NOTE Not taken into account when
%                           computing confidence.
%    IndDrfitSD             Each trial, select a value for drift rate,
%                           independently for stimulus 1 and for stimulus 2?
%                           Default is false so that there is only a single
%                           drift rate selected each trial from the relevant
%                           distribution. Boolean. NOTE Not taken into account when
%                           computing confidence.
% varargin: (optional) Array or cell array equal to the number of participants,
% specifying an example set of confidence reports. Simulated confidence
% reports will be mapped to the corresponding percentile of the example
% confidence reports in order to simulate idiosyncratic scale usage.


%% Initialisation

% Scale usage
if ~isempty(varargin)
    scaleUsage = varargin{1};
else
    scaleUsage = [];
end

if isempty(scaleUsage)
    disp('No idiosyncratic confidence scale usage provided.')
elseif iscell(scaleUsage)
    disp('Idiosyncratic confidence scale useage provided for all participants.')
else
    disp('Idiosyncratic confidence scale useage provided for one participant.')
end
    
% Set defaults
requiredFields  = {'TotalTrials', 'BlockSize', 'DeltaT', 'Fps', ...
    'Units', 'NumPtpnts', ...
    'NoiseSD', 'Threshold', 'OverallCommitDelay', ...
    'CommitDelaySD', 'WithinPtCommitDelaySD', ...
    'SeperateConf', 'ConfNoiseSd', 'RandRtLapseRate', ...
    'MappingLapseRate', 'ConfLapseRate', ...
    'Dots', 'BlockSettings', 'ConfCalc', ...
    'PermitCoM', 'DriftSD', ...
    'RngSeed', 'ObserverNoiseRatio', 'StimLambda', 'StimPropNoiseSD', ...
    'RespLapseRate', 'PosConfWeight', 'IndDriftSD'};

% Check there are no extra fields, but allow extra permitted fields that
% are redundant but helpful.
names = fieldnames(Settings);
permittedFields = requiredFields;
permittedFields(end+1 : end+3) = {'Name', 'ThreshIntercept', 'ThreshSlope'};
if any(~ismember(names, permittedFields))
    error('Incorrect use of fields in input ''Settings'' struct.')
end

DefaultBlockSettings(1).DotDist = @() defaultDotDist('forcedExp');
DefaultBlockSettings(1).MaxDuration = @() 16;
DefaultBlockSettings(1).Type = 'free';
DefaultBlockSettings(1).StimAfterResp = 20;
DefaultBlockSettings(1).ConfAccumulationTime = Inf;
DefaultBlockSettings(1).ForcedEarlyRespProb = {};

DefaultBlockSettings(2).DotDist = @() defaultDotDist('forcedExp');
DefaultBlockSettings(2).MaxDuration = @() 60;
DefaultBlockSettings(2).Type = 'free';
DefaultBlockSettings(2).StimAfterResp = 20;
DefaultBlockSettings(2).ConfAccumulationTime = Inf;
DefaultBlockSettings(2).ForcedEarlyRespProb = {};

DefaultBlockSettings(3).DotDist = @() defaultDotDist('forcedExp');
DefaultBlockSettings(3).MaxDuration = @defaultForcingDist;
DefaultBlockSettings(3).Type = 'forced';
DefaultBlockSettings(3).StimAfterResp = 0;
DefaultBlockSettings(3).ConfAccumulationTime = Inf;
DefaultBlockSettings(3).ForcedEarlyRespProb = 0.2;

DefaultDotsSettings.Max = 400;
DefaultDotsSettings.Min = 0;
DefaultDotsSettings.Sd = 40;

defaultThreshold = @(t, blockType)threshold_linear(t, blockType, ...    
                                                [240 720 inf]', [0 0 0]');

defaults = {640, 40, 0.01, 20, ...
    0.05, 20, ...
    4 * 40 / ( (0.05)^0.5 ), defaultThreshold, 7, ...
    1, 1, ...
    0, 1, 0, ...
    0.05, 0, ...
    DefaultDotsSettings, DefaultBlockSettings, 'prob', ...
    true, 0, ...
    'random', 0.5, 1, 0, ...
    0, 1, false};

for iField = 1 : length(requiredFields)    
    if ~isfield(Settings, requiredFields{iField})
        Settings.(requiredFields{iField}) = defaults{iField};
        
        disp(['Default setting applied for ' requiredFields{iField} '.'])
        try disp(num2str(defaults{iField})); catch; end
    end
end

% Convert inputs which specify a time into units of seconds
Settings.OverallCommitDelay = Settings.OverallCommitDelay * Settings.Units;
Settings.WithinPtCommitDelaySD = Settings.WithinPtCommitDelaySD * Settings.Units;
Settings.CommitDelaySD = Settings.CommitDelaySD * Settings.Units;

for iBlockType = 1 : length(Settings.BlockSettings)
    Settings.BlockSettings(iBlockType).MaxDuration = ...
        @() Settings.BlockSettings(iBlockType).MaxDuration() * Settings.Units;
    
    Settings.BlockSettings(iBlockType).StimAfterResp = ...
        Settings.BlockSettings(iBlockType).StimAfterResp * Settings.Units;    
    
    Settings.BlockSettings(iBlockType).ConfAccumulationTime = ...
        Settings.BlockSettings(iBlockType).ConfAccumulationTime * Settings.Units;
end

% Update the record of the time unit used
Settings.Units = 1;

% Seed the random generator
if strcmp(Settings.RngSeed, 'random')
    rng('shuffle');
elseif strcmp(Settings.RngSeed, 'fixed')
    rng(10);
else
    error('Unknown setting')
end

    
%% Loops

% Loop through participants
SimData = struct();
for iPtpnt = 1 : Settings.NumPtpnts
    
    % Initialise
    SimData(iPtpnt).SimSettings = Settings;
    assert(Settings.Units == 1)
    SimData(iPtpnt).TimeUnit = Settings.Units;
    SimData(iPtpnt).Fps = Settings.Fps;
    SimData(iPtpnt).Raw.Block(:, 1) = ...
        ceil((1 : Settings.TotalTrials) / Settings.BlockSize);
    SimData(iPtpnt).Raw.BlockType = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.IsForcedResp = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.StimLoc = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.Ref = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.PlannedDuration = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.ActualDurationPrec = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.Dots = cell(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.RtPrec = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.Resp = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).Raw.Acc = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).SimHist.FinalAccumulator1 = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).SimHist.FinalAccumulator2 = NaN(Settings.TotalTrials, 1);
    SimData(iPtpnt).SimHist.TrialCommitDelay = NaN(Settings.TotalTrials, 1);
    if Settings.IndDriftSD; num=2; else; num=1; end
    SimData(iPtpnt).SimHist.EvidenceQual = NaN(Settings.TotalTrials, num);
    
    % Set idiosyncratic scale usage if there is any
    if ~isempty(scaleUsage) && iscell(scaleUsage)
        SimData(iPtpnt).SimSettings.ScaleUsage = scaleUsage{iPtpnt};
    elseif ~isempty(scaleUsage)
        SimData(iPtpnt).SimSettings.ScaleUsage = scaleUsage;
    end
    
    % Add variability to the CommitDelay accross participants, but with some 
    % limits on the values that PtpntCommitDelay can take
    SimData(iPtpnt).SimSettings.PtpntCommitDelay = NaN;
    while ~(SimData(iPtpnt).SimSettings.PtpntCommitDelay >= 0)
        
        SimData(iPtpnt).SimSettings.PtpntCommitDelay = ...
            SimData(iPtpnt).SimSettings.OverallCommitDelay + ...
            (randn(1) * SimData(iPtpnt).SimSettings.CommitDelaySD);
    end
    
    % Alternate blocks of the different conditions
    numConds = length(Settings.BlockSettings);
    SimData(iPtpnt).Raw.BlockType(:, 1) = ...
        mod(SimData(iPtpnt).Raw.Block, numConds) +1;
    
    % Store the response type used in each trial
    for blockType = unique(SimData(iPtpnt).Raw.BlockType)'    
        if strcmp(SimData(iPtpnt).SimSettings.BlockSettings(blockType).Type, ...
                'forced')
            isForcedResp = true;
            
        elseif strcmp(SimData(iPtpnt).SimSettings.BlockSettings(blockType).Type, ...
                'free')
            isForcedResp = false;
            
        else
            error('Unknown block type')
        end
        
        SimData(iPtpnt).Raw.IsForcedResp( ...
                SimData(iPtpnt).Raw.BlockType == blockType) = isForcedResp;
    end
    
    % Alternate trials between the two stim locations
    SimData(iPtpnt).Raw.StimLoc(:, 1) = mod(1 : length(SimData(iPtpnt).Raw.Acc), 2) +1;
    
    % Loop through trials
    for iTrial = 1 : Settings.TotalTrials   
        if mod(iTrial, 10000)==0
            disp(['Participant ' num2str(iPtpnt) ...
                '. Trials complete: ' num2str(iTrial) '.'])
        end
        
        % In addition to between participant CommitDelay variability added 
        % above. Add some within participant variability too
        SimData(iPtpnt).SimHist.TrialCommitDelay(iTrial, 1) = NaN;
        
        while ~(SimData(iPtpnt).SimHist.TrialCommitDelay(iTrial) >= 0)    
            
            SimData(iPtpnt).SimHist.TrialCommitDelay(iTrial) = ...
                SimData(iPtpnt).SimSettings.PtpntCommitDelay  + ...
                (randn(1) * SimData(iPtpnt).SimSettings.WithinPtCommitDelaySD);
        end
       
        % Draw the high dot mean and low dot mean, from the function that
        % specifies the distribution over these.
        [hiMean, loMean] = ...
            Settings.BlockSettings(SimData(iPtpnt).Raw.BlockType(iTrial)).DotDist();
        assert(hiMean >= loMean)
        
        SimData(iPtpnt).Raw.Ref(iTrial, 1) = ((hiMean - loMean)/2) + loMean;
        SimData(iPtpnt).Raw.Diff(iTrial, 1) = hiMean - loMean;
        
        % Draw the maximum duration of the stimulus
        plannedDuration = ...
            Settings.BlockSettings(SimData(iPtpnt).Raw.BlockType(iTrial)).MaxDuration();
        
        SimData(iPtpnt).Raw.PlannedDuration(iTrial) ...
            = (ceil(plannedDuration * Settings.Fps))/Settings.Fps;
        
        % Determine the quality of evidence encoding this trial
        if Settings.DriftSD ~= 0
            if ~Settings.IndDriftSD
                SimData(iPtpnt).SimHist.EvidenceQual(iTrial, 1) = ...
                    (randn(1) * Settings.DriftSD) + 1;
            else
                SimData(iPtpnt).SimHist.EvidenceQual(iTrial, [1, 2]) = ...
                    (randn(1, 2) * Settings.DriftSD) + 1;
            end
        else
            if ~Settings.IndDriftSD
                SimData(iPtpnt).SimHist.EvidenceQual(iTrial, 1) = 1;
            else
                SimData(iPtpnt).SimHist.EvidenceQual(iTrial, [1, 2]) = [1, 1];
            end 
        end
        
        % Simulate the trial
        [SimData(iPtpnt), stimHist] = simulateTrial(SimData(iPtpnt), iTrial);
        assert(~isempty(stimHist))
 
        
        % Store the stimulus used, appending NaNs to account for fact that in
        % forced blocks the response can be up to 1 seconds after the
        % stimulus presentation ends
        assert(size(stimHist, 1) == 1)
        stimHist(1, :, (end +1) : (end +1 + SimData(iPtpnt).Fps)) = NaN;
        SimData(iPtpnt).Raw.Dots{iTrial} = stimHist;
    end
    
    assert(isequal(size(SimData(iPtpnt).Raw.Acc), ...
        size(SimData(iPtpnt).Raw.Resp)))
    
    % Convert SimData.Raw.Dots from a cell array to an double array.
    % How long is the longest element
    longestElement = max(cellfun(@(element) size(element, 3), ...
        SimData(iPtpnt).Raw.Dots));
    
    dotsDouble = NaN(Settings.TotalTrials, 2, longestElement);
    
    for iTrial = 1 : length(SimData(iPtpnt).Raw.Dots)
        
        dotsDouble(iTrial, :, 1 : size(SimData(iPtpnt).Raw.Dots{iTrial}, 3)) = ...
            SimData(iPtpnt).Raw.Dots{iTrial};
    end
    SimData(iPtpnt).Raw.Dots = dotsDouble;
    
    % Compute dots difference
    SimData(iPtpnt).Raw.DotsDiff = SimData(iPtpnt).Raw.Dots(:, 2, :) - ...
        SimData(iPtpnt).Raw.Dots(:, 1, :);
    
    SimData(iPtpnt).Raw.DotsDiff = permute(SimData(iPtpnt).Raw.DotsDiff, [1, 3, 2]);
    assert(all(size(SimData(iPtpnt).Raw.DotsDiff) == ...
                    [length(SimData(iPtpnt).Raw.RtPrec), longestElement]))
    
    
    % Add a confidence rating
    SimData(iPtpnt) = addSimConfidence(SimData(iPtpnt));
end


% Convert the data strcutre into the standard format described in 
% mat-comp-model-tools repository readme

% Checks
if strcmp(Settings.ConfCalc, 'NDsc') || strcmp(Settings.ConfCalc, 'TrDs')
    if (~isempty(Settings.ObserverNoiseRatio)) ...
            && (~isnan(Settings.ObserverNoiseRatio))
        error('Bug')
    end
end

TimeUnit = NaN(length(SimData), 1);
Fps = NaN(length(SimData), 1);

for iPtpnt = 1 : length(SimData)
    
    TimeUnit(iPtpnt) = SimData(iPtpnt).TimeUnit;
    Fps(iPtpnt) = SimData(iPtpnt).Fps;
    
    DSet.P(iPtpnt).Data = SimData(iPtpnt).Raw;
    DSet.P(iPtpnt).SimSettings = SimData(iPtpnt).SimSettings;
    DSet.P(iPtpnt).SimHist = SimData(iPtpnt).SimHist;
    DSet.P(iPtpnt).Sim.Params = ...
        switchParamCoding([], [], Settings, 'modelling');
    
    % To make some plotting easier also store EvidenceQual with the raw
    % data
    DSet.P(iPtpnt).Data.EvidenceQual = ...
        DSet.P(iPtpnt).SimHist.EvidenceQual;
end

TimeUnit = unique(TimeUnit);
if length(TimeUnit) ~= 1; error('Bug'); end
DSet.Spec.TimeUnit = TimeUnit;

Fps = unique(Fps);
if length(Fps) ~= 1; error('Bug'); end
DSet.Spec.Fps = Fps;

DSet.Spec.Dots = Settings.Dots;
DSet.Spec.DotsSd = Settings.Dots.Sd;

% Is the same dot dist used for all blocks?
DSet.Spec.Dots.Dist = Settings.BlockSettings(1).DotDist;

for iBlock = 1 : length(Settings.BlockSettings)
    if ~isequal(DSet.Spec.Dots.Dist, Settings.BlockSettings(iBlock).DotDist)
        DSet.Spec.Dots.Dist = 'Depends on block';
        break
    end
end

       
    





